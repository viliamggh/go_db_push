package main

import (
	"context"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/Azure/azure-sdk-for-go/sdk/storage/azblob"
	mssql "github.com/microsoft/go-mssqldb"
)

type StatementFile struct {
	AccountStatement AccountStatement `json:"accountStatement"`
}

type AccountStatement struct {
	Info struct {
		DateStart      string  `json:"dateStart"`
		DateEnd        string  `json:"dateEnd"`
		OpeningBalance float64 `json:"openingBalance"`
		ClosingBalance float64 `json:"closingBalance"`
	} `json:"info"`
	TransactionList struct {
		Transaction []Transaction `json:"transaction"`
	} `json:"transactionList"`
}

type Transaction struct {
	Column22 *Column `json:"column22"`
	Column0  *Column `json:"column0"`
	Column1  *Column `json:"column1"`
	Column14 *Column `json:"column14"`
	Column25 *Column `json:"column25"`
	Column8  *Column `json:"column8"`
	Column9  *Column `json:"column9"`
	Column17 *Column `json:"column17"`
	Column5  *Column `json:"column5"`
	// ... add others as needed
}

type Column struct {
	Value interface{} `json:"value"`
	Name  string      `json:"name"`
	ID    int         `json:"id"`
}

func azAuth() (*azidentity.DefaultAzureCredential, error) {
	cred, err := azidentity.NewDefaultAzureCredential(nil)
	if err != nil {
		log.Fatalf("failed to obtain credential: %v", err)
		return nil, fmt.Errorf("failed to unmarshal: %w", err)
	}
	return cred, nil
}

func initBlobClient(storageAccountName string, cred *azidentity.DefaultAzureCredential) (*azblob.Client, error) {
	serviceURL := fmt.Sprintf("https://%s.blob.core.windows.net", storageAccountName)

	blobClient, err := azblob.NewClient(serviceURL, cred, nil)
	if err != nil {
		return nil, err
	}

	return blobClient, nil
}

func getTxsFromBlobFile(ctx context.Context, blobClient *azblob.Client, containerName, blobName string) ([]Transaction, error) {
	// returns transactions from particular blobFile
	downloadResp, err := blobClient.DownloadStream(ctx, containerName, blobName, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to download blob %s: %w", blobName, err)
	}

	data, err := io.ReadAll(downloadResp.Body)

	if err != nil {
		return nil, fmt.Errorf("failed to read blob data %s: %w", blobName, err)
	}
	defer downloadResp.Body.Close()

	// 2. Parse JSON
	var statementFile StatementFile
	if err := json.Unmarshal(data, &statementFile); err != nil {
		return nil, fmt.Errorf("failed to unmarshal: %w", err)
	}

	txs := statementFile.AccountStatement.TransactionList.Transaction
	log.Printf("Found %d transactions in blob %s\n", len(txs), blobName)

	return txs, nil
}

func initDbConnector(sqlServerName, dbName string, cred *azidentity.DefaultAzureCredential, ctx context.Context) (driver.Connector, error) {

	host := fmt.Sprintf("%s.database.windows.net", sqlServerName)
	connStr := fmt.Sprintf("server=%s;database=%s", host, dbName)

	connector, err := mssql.NewAccessTokenConnector(
		connStr,
		func() (string, error) {
			t, err := cred.GetToken(ctx, policy.TokenRequestOptions{
				Scopes: []string{"https://database.windows.net/.default"},
			})
			if err != nil {
				return "", err
			}
			return t.Token, nil
		},
	)
	if err != nil {
		return nil, err
	}

	return connector, nil
}

func upsertTxs(txs []Transaction, db *sql.DB) {
	// logic generated by chGPT, review in case of any suspicion
	// Use a T-SQL MERGE statement to upsert:
	//  - "WHEN MATCHED" -> transaction ID exists -> update certain fields
	//  - "WHEN NOT MATCHED" -> insert a new row
	mergeSQL := `
		MERGE [dbo].[Transactions] WITH (HOLDLOCK) AS target
		USING (VALUES (@p1, @p2, @p3, @p4, @p5, @p6, @p7)) AS source 
			([TransactionID], [TransactionDate], [Amount], [Currency], [Comment], [TransactionType], [PerformedBy])
			ON target.[TransactionID] = source.[TransactionID]

		WHEN MATCHED
			-- Only update if *something* changed:
			AND (
				COALESCE(target.[TransactionDate], '1900-01-01') 
					<> COALESCE(source.[TransactionDate], '1900-01-01')
				OR COALESCE(target.[Amount], -999999999) 
					<> COALESCE(source.[Amount], -999999999)
				OR COALESCE(target.[Currency], '') 
					<> COALESCE(source.[Currency], '')
				OR COALESCE(target.[Comment], '') 
					<> COALESCE(source.[Comment], '')
				OR COALESCE(target.[TransactionType], '') 
					<> COALESCE(source.[TransactionType], '')
				OR COALESCE(target.[PerformedBy], '') 
					<> COALESCE(source.[PerformedBy], '')
			)
		THEN
			UPDATE
			SET [TransactionDate] = source.[TransactionDate],
				[Amount]          = source.[Amount],
				[Currency]        = source.[Currency],
				[Comment]         = source.[Comment],
				[TransactionType] = source.[TransactionType],
				[PerformedBy]     = source.[PerformedBy],
				[UpdatedAt]       = SYSUTCDATETIME()

		WHEN NOT MATCHED THEN
			INSERT (
				[TransactionID],
				[TransactionDate],
				[Amount],
				[Currency],
				[Comment],
				[TransactionType],
				[PerformedBy]
			)
			VALUES (
				source.[TransactionID],
				source.[TransactionDate],
				source.[Amount],
				source.[Currency],
				source.[Comment],
				source.[TransactionType],
				source.[PerformedBy]
			)

		OUTPUT $action, inserted.[TransactionID];
		`

	// Prepare the statement once
	stmt, err := db.Prepare(mergeSQL)
	if err != nil {
		log.Printf("failed to prepare upsert statement: %v", err)
		return
	}
	defer stmt.Close()

	// Loop all transactions
	for _, t := range txs {
		txnID, err := getBigInt(t.Column22)
		if err != nil {
			log.Printf("Skipping row due to txnID parse error: %v\n", err)
			continue
		}
		txnDateStr, _ := getString(t.Column0)
		amount, _ := getFloat(t.Column1)
		currency, _ := getString(t.Column14)
		comment, _ := getString(t.Column25)
		txnType, _ := getString(t.Column8)
		performedBy, _ := getString(t.Column9)

		parsedDate, err := parseDateWithOffset(txnDateStr)
		if err != nil {
			log.Printf("Skipping row due to parseDateWithOffset error: %v\n", err)
			continue
		}

		// Execute the MERGE statement. Provide parameters in the same order
		// as the source subselect: (TransactionID, TransactionDate, etc.)
		_, err = stmt.Exec(
			txnID,       // @p1
			parsedDate,  // @p2
			amount,      // @p3
			currency,    // @p4
			comment,     // @p5
			txnType,     // @p6
			performedBy, // @p7
		)
		if err != nil {
			log.Printf("Upsert error for txnID=%d: %v\n", txnID, err)
			continue
		}
	}
}

func getBigInt(col *Column) (int64, error) {
	if col == nil || col.Value == nil {
		return 0, fmt.Errorf("missing column")
	}
	// JSON might decode numbers as float64
	switch v := col.Value.(type) {
	case float64:
		return int64(v), nil
	case int64:
		return v, nil
	case string:
		// parse?
	}
	return 0, fmt.Errorf("unsupported type for big int")
}

func getString(col *Column) (string, error) {
	if col == nil || col.Value == nil {
		return "", nil
	}
	switch v := col.Value.(type) {
	case string:
		return v, nil
	default:
		return "", fmt.Errorf("not a string")
	}
}

func getFloat(col *Column) (float64, error) {
	if col == nil || col.Value == nil {
		return 0, nil
	}
	switch v := col.Value.(type) {
	case float64:
		return v, nil
	default:
		return 0, fmt.Errorf("not a float64")
	}
}

// parseDateWithOffset might parse "2024-12-09+0100" to a time.Time
func parseDateWithOffset(dateStr string) (string, error) {
	if len(dateStr) < 10 {
		return "", fmt.Errorf("invalid date string: %s", dateStr)
	}
	// Return the first 10 characters: "YYYY-MM-DD"
	return dateStr[:10], nil
}

func main() {

	storageAccountName := "safintrackdev"
	containerName := "raw"
	sqlServerName := os.Getenv("AZURE_SQL_SERVER_NAME") // e.g. "myserver" (without .database.windows.net)
	dbName := os.Getenv("AZURE_SQL_DATABASE_NAME")

	// TODO: find out more details about this "context"
	ctx := context.Background()

	// authenticate to azure
	cred, err := azAuth()
	if err != nil {
		log.Fatalf("failed to obtain credential: %v", err)
	}

	// init blob client
	blobClient, err := initBlobClient(storageAccountName, cred)
	if err != nil {
		log.Fatalf("failed to create blob client: %v", err)
	}

	// init db conn
	connector, err := initDbConnector(sqlServerName, dbName, cred, ctx)
	if err != nil {
		log.Fatalf("Failed to create access token connector: %v", err)
	}
	db := sql.OpenDB(connector)
	defer db.Close()

	// process blobs
	pager := blobClient.NewListBlobsFlatPager(containerName, nil)
	log.Println("Listing blobs in container:", containerName)

	for pager.More() {
		page, err := pager.NextPage(ctx)
		if err != nil {
			log.Fatalf("error listing blobs: %v", err)
		}
		for _, blobItem := range page.Segment.BlobItems {
			fmt.Println(*blobItem.Name)
			txs, err := getTxsFromBlobFile(ctx, blobClient, containerName, *blobItem.Name)
			if err != nil {
				log.Fatalf("Failed to process transactions in blobFile: %v", err)
			}
			upsertTxs(txs, db)
		}
	}
}
